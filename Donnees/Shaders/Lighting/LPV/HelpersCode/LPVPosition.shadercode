/*
 * All function to compute 3D <-> 2D transform
 * Because we can write on 3D texture
 */

/* ========== WARNING these uniforms is need
uniform vec3 LPVPosition; // position of the grid
uniform vec4 LPVSize; // xy : texture dim & zw : repeat.
uniform vec4 LPVCellSize; // xyz dim & w number cell in one dim
 */
 
/* All methods :
 * ===== Methods to check and compute grid 3D coords
 * ComputeGridCoord
 * ===== Methods to acces to grid texture
 * Convert3Dto2DTexcoord
 * Convert2DTexcoordTo3D
 */

void ComputeGridCoord(inout vec3 position)
{
	position = floor((position-LPVPosition) / LPVCellSize.xyz);
}

bool IsInGrid(in vec3 p)
{
    return all(greaterThanEqual(p, vec3(0.0))) && all(lessThan(p, LPVCellSize.xyz));
}

vec2 Convert3DTo2DTexcoord(in vec3 pos){
    // Compute sub coordinates
	float row = floor(pos.z / LPVSize.z);
	float col = pos.z - (row*LPVSize.z);

	return vec2(col * LPVCellSize.w + pos.x,row * LPVCellSize.w + pos.y) / LPVSize.xy;
}

vec3 Convert2DTexcoordTo3D(in vec2 TexCoords){
  vec2 ImageCoord = TexCoords * LPVSize.xy;
  float row = floor(ImageCoord.y / LPVCellSize.w);
  float col = floor(ImageCoord.x / LPVCellSize.w);
  vec3 GridPosition;
  GridPosition.z = col + (row*LPVSize.z);
  GridPosition.xy = ImageCoord - vec2(col*LPVCellSize.w,row*LPVCellSize.w);
  return GridPosition;
}
