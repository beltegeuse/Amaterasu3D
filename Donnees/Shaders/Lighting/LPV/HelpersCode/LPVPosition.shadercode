/*
 * All function to compute 3D <-> 2D transform
 * Because we can write on 3D texture
 */

/* ========== WARNING these uniforms is need
uniform mat4 LPVMatrice; // position of the grid
uniform vec4 LPVSize; // xy : texture dim & zw : repeat.
uniform vec4 LPVCellSize; // xyz dim & w number cell in one dim
 */
 
 /*void ComputeGridCoord(inout vec3 position)
{
	position = floor((position-LPVPosition) / LPVCellSize.xyz);
}

bool IsInGrid(in vec3 p)
{
    return all(greaterThanEqual(p, vec3(0.0))) && all(lessThan(p, LPVCellSize.xyz));
}*/
 
/* All methods :
 * ===== Methods to check and compute grid 3D coords
 * ComputeGridCoord
 * ===== Methods to acces to grid texture
 * Convert3Dto2DTexcoord
 * Convert2DTexcoordTo3D
 */
 
 
bool IsNotInGrid(in vec3 p)
{
    return any(lessThan(p, vec3(0.0))) || any(greaterThanEqual(p, vec3(LPVNbCell)));
}

bool IsInGrid(in vec3 p)
{
    return all(greaterThanEqual(p, vec3(0.0))) && all(lessThan(p, vec3(LPVNbCell)));
}

vec2 Convert3Dto2D(in vec3 pos, in int level){
   	float row = floor(pos.z / LPVSize.z);
	float col = pos.z - (row*LPVSize.z);
	vec2 over = (pos.xy - clamp(pos.xy,vec2(0,0),vec2(LPVNbCell-1.0,LPVNbCell-1.0))) * 100.0;
	return vec2(col * LPVNbCell + pos.x + over.x * LPVSize.x,row * LPVNbCell + pos.y + over.y * LPVSize.y);
}


vec2 Convert3DTo2DTexcoord(in vec3 pos, in int level)
{
	return Convert3Dto2D(pos,level) / LPVSize.xy;
}

vec3 Convert2DTexcoordTo3D(in vec2 TexCoords){
  vec2 ImageCoord = TexCoords * LPVSize.xy;
  float row = floor(ImageCoord.y / LPVNbCell);
  float col = floor(ImageCoord.x / LPVNbCell);
  vec3 GridPosition;
  GridPosition.z = col + (row*LPVSize.z);
  GridPosition.xy = ImageCoord - vec2(col*LPVNbCell,row*LPVNbCell);
  return GridPosition;
}
